# Proposal: JSON Registry API V2

## Abstract

The docker registry is a service to manage information about docker images and
enable their distribution. While the current registry is usable, there are
several problems with the architecture that have led to this proposal. For
relevant details, please see the following issues:

- [docker/docker-registry#612](https://github.com/docker/docker-registry/issues/612)
- [docker/docker#8093](https://github.com/docker/docker/issues/8093)

The main driver of this proposal are changes to the docker the image format,
covered in [docker/docker#8093](https://github.com/docker/docker/issues/8093).
The new, self-contained image manifest simplifies the image defition and the
underlying backend layout. To reduce bandwidth usage, the new registry will be
architected to avoid uploading existing layers and will support resumable
layer uploads.

While out of scope for this specification, the URI layout of the new API will
be structured to support a rich Authentication and Authorization model by
leveraging namespaces.

Furthermore, to bring docker registry in line with docker core, the registry
is written in Go.

## Scope

This proposal covers the URL layout and protocols of the Docker Registry V2
JSON API. This will affect the docker core registry API and the rewrite of
docker-registry.

This includes the following features:

- Namespace-oriented URI Layout
- PUSH/PULL registry server for V2 image format
- Resumable layer PUSH support
- V2 Client library implementation

While authentication and authorization support will influence this
specification, details of the protocol will be left to a future specification.
Other features marked as next generation will be incorporated when the initial
support is complete. Please see the road map for details.

## Use Cases

For the most part, the use cases of the former registry API apply to the new
version. Differentiating uses cases are covered below.

### Resumable Push

Company X's build servers lose connectivity to docker registry before
completing an image layer transfer. After connectivity returns, the build
server attempts to re-upload the image. The registry notifies the build server
that the upload has already been partially attempted. The build server
responds by only sending the remaining data to complete the image file.

### Resumable Pull

Company X is having more connecitivity problems but this time in their
deployment datacenter. When downloading an image, the connection is
interrupted before completion. The client keeps the partial data and uses http
Range requests to avoid downloading repeated data.

### Layer Upload De-duplication

Company Y's build system creates two identical docker layers from build
processes A and B. Build process A completes uploading the layer before B.
When process B attempts to upload the layer, the registry indicates that its
not necessary because the layer is already known.

If process A and B upload the same layer at the same time, both operations
will proceed and the first to complete will be stored in the registry (Note:
we may modify this to prevent dogpile with some locking mechanism).

### Access Control

Company X would like to control which developers can push to which
repositories. By leveraging the URI format of the V2 registry, they can
control who is able to access which repository, who can pull images and who
can push layers.

## Dependencies

Initially, a V2 client will be developed in conjunction with the new registry
service to facilitate rich testing and verification. Once this is ready, the
new client will be used in docker to communicate with V2 registries.

## Proposal

This section covers proposed client flows and details of the proposed API
endpoints. All endpoints will be prefixed by the API version and the
repository name:

	/v2/<name>/

For the purpose of api methods, `name` always includes two path components.
For example, an API endpoint that will work with the `library/ubuntu`
repository, the URI prefix will be:

	/v2/library/ubuntu/

This scheme will provide rich access control over various operations and
methods using the URI prefix and http methods that can be controlled in
vareity of ways.

A detailed list of methods and URIs are covered in the table below:

 Method  | URI                                       | Target Object  | Description                                                                                         |
 --------|-------------------------------------------|----------------|-----------------------------------------------------------------------------------------------------|
  GET    | `/v2/<name>/image`                        | Image Manifest | Fetch the image manifest identified by `name` for default tag "latest".                             |
  GET    | `/v2/<name>/image/<tag>`                  | Image Manifest | Fetch the image manifest identified by `name` and `tag`.                                            |
  PUT    | `/v2/<name>/image`                        | Image Manifest | Upload the image manifest identified by `name` for default tag "latest".                            |
  DELETE | `/v2/<name>/image`                        | Image Manifest | Delete the image identified by `name` for default tag "latest".                                     |
  DELETE | `/v2/<name>/image/<tag>`                  | Image Manifest | Delete the image identified by `name` and `tag`.                                                    |
  GET    | `/v2/<name>/tags`                         | Tags           | Fetch the tags under the repository identified by `name`.                                           |
  GET    | `/v2/<name>/layer/<tarsum>`               | Layer          | Fetch the layer identified by `tarsum`.                                                             |
  POST   | `/v2/<name>/layer/<tarsum>`               | Layer          | Initiate an upload of the layer identified by `tarsum`. Requires `length` and a checksum parameter. |
  GET    | `/v2/<name>/layer/<tarsum>/upload/<uuid>` | Layer          | Get the status of the upload identified by `tarsum` and `uuid`.                                     |
  PUT    | `/v2/<name>/layer/<tarsum>/upload/<uuid>` | Layer          | Upload all or a chunk of the upload identified by `tarsum` and `uuid`.                              |

All endpoints should support aggressive http caching, compression and range
headers, where appropriate. Details of each method are covered in the
following sections.

The new API will attempt to leverage HTTP semantics where possible but may
break from standards to implement targeted features.

### Errors

Actionable failure conditions, covered in detail in their relevant sections,
will be reported as part of 4xx responses, in a json response body. The format
is as follows:

    {
        "code": <error identifier>,
        "message": <message describing condition>,
        "detail": <unstructured>
    }

The `code` field will be a unique identifier, all caps with underscores by
convention. The `message` field will be a human readable string. The optional
`detail` field may contain arbitrary json data providing information the
client can use to resolve the issue.

### Pulling An Image

An "image" is a combination of a JSON manifest and individual layer files. The
process of pulling an image centers around retrieving these two components.

The first step in pulling an image is to retrieve the manifest. For reference,
the relevant manifest fields for the registry are the following:

 field    | description                                    |
----------|------------------------------------------------|
name      | The name of the image.                         |
tag       | The tag for this version of the image.         |
fsLayers  | A list of layer descriptors (including tarsum) |
signature | A JWS used to verify the manifest content      |

For more information about the manifest format, please see
[docker/docker#8093](https://github.com/docker/docker/issues/8093).

When the manifest is in hand, the client must verify the signature to ensure
the names and layers are valid. Once confirmed, the client will then use the
tarsums to download the indvidual layers.

The API details follow.

#### Pulling an Image Manifest

The image manifest can be fetched with one of the two following urls:

	GET /v2/<name>/image
	GET /v2/<name>/image/<tag>

The "name" parameter should be the name of the requested image and is
required. The tag portion of the manifest is optional and if not specified,
the default tag "latest" will be used.

A `404 Not Found` response will be returned if the image is unknown to the
registry. If the image exists and the response is successful, the image
manifest will be returned, with the following format (see docker/docker#8093
for details):

    {
       "name": <name>,
       "tag": <tag>,
       "fsLayers": [
          {
             "blobSum": <tarsum>
          },
          ...
        ]
       ],
       "history": <v1 images>,
       "signature": <JWS>
    }

The client should verify the returned manifest signature for authenticity
before fetching layers.

#### Pulling a Layer

Pulling a layer is carried out by a standard http request. The URL is as
follows:

    GET /v2/<name>/layer/<tarsum>

Access to a layer will be gated by the `name` of the repository but is
identified uniquely in the registry by `tarsum`. The `tarsum` parameter is an
opaque field, to be interpreted by the tarsum library.

This endpoint may issue a 307 (302 for <HTTP 1.1) redirect to another service
for downloading the layer and clients should be prepared to handle redirects.

This endpoint should support aggresive HTTP caching for image layers. Support
for etags, modification dates and other cache control headers should be
included. To allow for incremental downloads, `Range` requests should be
supported, as well.

### Pushing An Image

Pushing an image works in the opposite order as a pull. After assembling the
image manifest, the client must first push the individual layers. When the
layers are fully pushed into the registry, the client should upload the signed
manifest.

The details of each step of the process are covered in the following sections.

#### Pushing a Layer

All layer uploads use two steps to manage the upload process. The first step
starts the upload in the registry service, returning a url to carry out the
second step. The second step uses the upload url to transfer the actual data.
Uploads are started with a POST request which returns a url that can be used
to push data and check upload status.

The `Location` header will be used to communicate the upload location after
each request. While it won't change in the this specification, clients should
use the most recent value returned by the API.

##### Starting An Upload

To begin the process, a POST request should be issued in the following format:

	POST /v2/<namespace>/layer/<tarsum>?length=<size of layer file>&(md5|sha1|sha256|sha512)=<checksum>

The parameters of this request are the owner namespace, the layer tarsum and
optionally a checksum, which will used to validate that the upload is
complete. These parameters may be submitted as part of the url query string or
as standard form parameters.

##### Existing Layers

If the layer with the tarsum is already present in the namespace, a `304 Not
Modified` response will be returned:

	304 Not Modified
	Location: /v2/<namespace>/layer/<tarsum>

When this response is received, the client can assume that the layer is
already available in the registry and should take no further action to upload
the layer. Note that the checksums may differ for the existing registry layer,
but the tarsums will be guaranteed to match.

##### Uploading the Layer

If the POST request is successful, a `202 Accepted` response will be returned
with the upload URL in the `Location` header:

	202 Accepted
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Range: bytes=0-<offset>/<length>
	Content-Length: 0

The rest of the upload process can be carried out with the returned url,
called the "Upload URL" from the `Location` header. All responses to the
upload url, whether sending data or getting status, will be in this format.

##### Upload Progress

The progress and chunk coordination of the upload process will be coordinated
through the `Range` header. While this is a non-standard use of the `Range`
header, there are examples of
[similar approaches](https://developers.google.com/youtube/v3/guides/using_resumable_upload_protocol)
in APIs with heavy use. For an upload that just started, for an example with
a 1000 byte layer file, the `Range` header would be as follows:

	Range: bytes=0-0/1000

To get the status of an upload, issue a GET request to the upload URL:

	GET /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Host: <registry host>

The response will be similar to the above, except will return 204 status:

	204 No Content
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Range: bytes=0-<offset>/<length>

##### Monolithic Upload

To carry out a "monolithic" upload, one can simply put the entire content blob
to the provided URL:

	PUT /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Content-Length: <size of layer>
	Content-Type: application/octet-stream

	<Layer Binary Data>

If successful, the server will return a 201 Created response,indicating the
upload is complete:

	201 Created
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Content-Length: 0

##### Chunked Upload

To carry out an upload of a chunk, the client can specify a range header and
only include that part of the layer file:

	PUT /v2/<name>/layer/<tarsum>/upload/<uuid>
	Location: /v2/<name>/layer/<tarsum>/upload/<uuid>
	Content-Length: <size of chunk>
	Content-Range: <start of range>-<end of range>/<layer size>
	Content-Type: application/octet-stream

	<Layer Chunk Binary Data>

There is no enforcement on layer chunk splits other than that the server must
receive them in order. The server may enforce a minimum chunk size. If the
server cannot accept the chunk, a `416 Requested Range Not Satisfiable`
response will be returned and will include a `Range` header indicating the
current status:

	416 Requested Range Not Satisfiable
	Location: /v2/<name>/layer/<tarsum>/upload/<uuid>
	Range: 0-<last valid range>/<layer size>
	Content-Length: 0

If this response is received, the client should resume from the "last valid
range" and upload subsequent chunk. A 416 will be returned under the following
conditions:

- Invalid Content-Range header format
- Out of order chunk: the range of the next chunk must start after the "last
  valid range" from the last response.

When a chunk is accepted as part of the upload, a `202 Accepted` response will
be returned, including a `Range` header with the current upload status:

	202 Accepted
	Location: /v2/<name>/layer/<tarsum>/upload/<uuid>
	Range: bytes=0-<offset>/<length>
	Content-Length: 0

##### Completed Upload

When the last chunk is received and the layer has been validated, the client
will receive a `201 Created` response:

	201 Created
	Location: /v2/<namespace>/layer/<tarsum>
	Content-Length: 0

The `Location` header will contain the registry URL to access the accepted
layer file.

##### Errors

If an 502, 503 or 504 error is received, the client should assume that the
download can proceed due to a temporary condition, honoring the appropriate
retry mechanism. Other 5xx errors should be treated as terminal.

If there is a problem with the upload, a 4xx error will be returned indicating
the problem. After receiving a 4xx response (except 416, as called out above),
the upload will be considered failed and the client should take appropriate
action.

The following table covers the various error conditions that may be returned
after completing a layer upload:

 Code            | Message                                          |
-----------------|--------------------------------------------------|
INVALID_CHECKSUM | provided checksum did not match uploaded content |
INVALID_LENGTH   | provided length did not match content length     |
INVALID_TARSUM	 | provided tarsum did not match binary content     |

Note that the upload url will not be available forever. If the upload uuid is
unknown to the registry, a `404 Not Found` response will be returned and the
client must restart the upload process.

#### Pushing an Image Manifest

Once all of the layers for an image are uploaded, the client can upload the
image manifest. An image can be pushed using the following request formats:

    PUT /v2/<name>/image/<tag>

    {
       "name": <name>,
       "tag": <tag>,
       "fsLayers": [
          {
             "blobSum": <tarsum>
          },
          ...
        ]
       ],
       "history": <v1 images>,
       "signature": <JWS>,
       ...
    }

The `name` and `tag` fields of the response body must match those specified in
the URL.

If there is a problem with pushing the manifest, a relevant 4xx response will
be returned with a JSON error message. The following table covers the various
error conditions and their corresponding codes:

 Code                | Message                                          |
---------------------|--------------------------------------------------|
INVALID_NAME         | Manifest name did not match URI                  |
INVALID_TAG          | Manifest tag did not match URI                   |
UNVERIFIED_MANIFEST  | Manifest failed signature validation             |
UNKNOWN_LAYER        | Referenced layer `<tarsum>` not available        |
UNTRUSTED_SIGNATURE  | Manifest signed by untrusted source              |

For the `UNKNOWN_LAYER` error, the `detail` field of the error response should
identify the missing layer, by tarsum:

    {
        "code": "UNKNOWN_LAYER",
        "message": "Referenced layer `<tarsum>` not available",
        "detail": {
            "missing": {
                "fsLayers": [
                    "blobSum": <tarsum>
                ],
                ...
            }
        }
    }

#### Listing Image Tags

It may be necessary to list all of the tags under a given repository. The tags
for an image repository can be retrieved with the following request:

    GET /v2/<name>/tags

The response will be in the following format:

    200 OK
    Content-Type: application/json

    {
        "name": <name>,
        "tags": [
            <tag>,
            ...
        ]
    }

For repositories with a large number of tags, this response may be quite
large, so care should be taken by the client when parsing the response to
reduce copying.

### Deleting an Image

An image may be deleted from the registry via its `name` and `tag`. A delete
may be issued with the following request format:

    DELETE /v2/<name>/image/<tag>

If the image exists and has been successfully deleted, the following response
will be issued:

    202 Accepted
    Content-Length: None

If the image had already been deleted or did not exist, a `404 Not Found`
response will be issued instead.

## Roadmap

- [ ] Write Registry REST API V2 proposal
	- [ ] Solicit feedback
- [ ] Implement V2 API server
	- [ ] Basic Layer API
	- [ ] Basic Image API
	- [ ] Resumable upload support
- [ ] Implement V2 API client
- [ ] Implement API compliance tests
- [ ] Port docker core to use client from registry project for v2 pushes
