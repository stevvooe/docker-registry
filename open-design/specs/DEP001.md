Place this file in open-design/specs/

TODO(sday): This should be a proposal for only the external API definition. We
need to remove much of the information about the implementation.

already here

# DEP001: Registry REST API V2

docker/docker#8093
docker/docker-registry#612

## Abstract

The docker registry is a service to manage information about docker images and
enable their distribution. While the current registry is usable, there are
several problems with the current implementation that have led to this
proposal.

The main driver of this proposal are changes to the docker the image format,
covered in docker/docker#8093. The new, self-contained image manifest
simplifies the underlying backend layout. The authorization and access control
will also be changed to support multiple use cases and reduce transits between
all parties after authentication and authorization. To reduce bandwidth usage,
the new registry will be architected to support resumable layer uploads and
layer upload deduplication.

Furthermore, to bring docker registry in line with docker core, the registry
will be rewritten in Go.

Important Features:

- Resumable PUSH
- Don't reupload existing layers
- Rest URL must reflect namespace to be used to grant access

## Scope

This specification covers changes to the Docker Registry API V2 and a minimal
set of features for the initial version.

This includes the following features:

- Basic PUSH/PULL registry server for new image format
- V2 Client library
- Resumable layer PUSH support
- Access control methodology

Other features marked as next generation will be incorporated when the initial
support is complete. Please see the road map for details.

## Use Cases

### Resumable Push

Company X's build servers lose connectivity to docker registry before
completing an image layer transfer. After connectivity returns, the build
server attempts to re-upload the image. The registry notifies the build server
that the upload has already been partially attempted. The build server
responds by only sending the remaining data to complete the image file.

### Layer Upload Deduplication

Company Y's build system creates two identical docker layers from build
processes A and B. Build process A completes uploading the layer before B.
When process B attempts to upload the layer, the registry indicates that its
not necessary because the layer is already known.

If process A and B upload the same layer at the same time, both operations
will proceed and the first to complete will be stored in the registry (Note:
we may modify this to prevent dogpile with some locking mechanism).

### Access Control

Company Z needs would prefer not to host their own registry but wants to
ensure that other parties due not have access to their docker images. Thier
images are a combination of publicly avialable images and their own internal
images.

- Push company-z/foo, based on company-y/public succeeds
- Push company-z/bar, based on company-z/private fails without permission

#### PUSH

#### PULL

## Dependencies

- Bearer token based access control.

### Third Party Software

#### Redis

[Redis](http://redis.io/) will be used as a shared scratch space, small object
caching layer and coordination. A "cluster" of registry instances should share
a common redis instance.

## Proposal

PUSH image process:
- Upload resources (layers, etc.)
- Upload manifest
- validate and store the manifest, ensuring layers are present

PUSH layer:
- sequential upload
	- validate layer with tarsum computation
	- Can tarsum resume its hash computation? Or do we do filesystem buffering.
- Once the file is uploaded, store in sha512 hash store
- Link tarsum id back to image id
- Associate layer with namespace
- Even if we already have content, we can validate that client has content by requesting arbitrary hash

PUSH image:

- Push JSON image to REST URI /<namespace>/<tag>
- make sure name and namespace match, and tag match
- verify that tarsums exist already
- validate signature in manifest (registry re-sign image on push?)
- upload namespace/tag to storage (atomicity?)

PULL image:
- Validate access to namespace in authorization token
- Use namespace in url to get image manifest
- Return manifest to client
- Client proceeds to download layers

PULL layer
 TODO(sday): Cover the details of this process.

### API Endpoints

#### Images

##### PULL Image

	GET /v2/image/<name>
	GET /v2/image/<name>/<tag>

Fetch the image manifest identified by `name`. If the tag is unspecified, the
default of `latest` will be used.

Parameters:

- _name_ (required): The namespace of the requested image.
- _tag_ (optional, default: "latest"): The tag of the requested image.

If the image exists and the response is successful, the image manifest
will be returned in the following format:

	TODO(sday): See docker/docker#8093

Errors:

TODO(sday): Cover application level errors
TODO(sday): Authentication errors covered below

Example request:
	
```
GET /v2/image/foo/bar
Host: registry.docker.io
Authorization: Bearer <access token>
```

##### PUSH Image

	PUT /v2/image/<name>
	PUT /v2/image/<name>/<tag>

#####

	DELETE /v2/image/<name>/<tag>

##### List Tags

	GET /v2/image/<name>/tags

#### Layers

##### PULL Layer

	GET /v2/layer/<tarsum>

##### PUSH Layer

	PUT /v2/layer/<tarsum>

### Authentication and Authorization

Access, Authentication and Authorization for resources are controlled using a
[bearer authentication](https://tools.ietf.org/html/rfc6750#section-3.1)
token. Such a token can be obtained through 

#### Bearer Token Format

TODO(sday): This will mostly follow [JWT](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-30), using scopes.

Checkout 6.1 for an unsigned example

https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-30#section-6.1

Scope format is space delimited:
	
	<namespace>:pull[,push]

Example with pull access on foo/bar:

	foo/bar:pull

Example with push and pull access on foo/bar:

	foo/bar:pull,push

Example with multiple scopes in claimset:

	foo/bar:pull,push foo/baz:pull

See go JWT library for scope example: http://godoc.org/code.google.com/p/goauth2/oauth/jwt

Scope is used heavily across OAuth providers (google, facebook, salesforce, etc.)

#### Error Responses

401 Unauthorized

invalid_token - returned when the token is invalid or expired
insufficient_scope - returned when the tokens scope does not cover the resource

Example response when using an expired token:

	```
	GET /v1/image/foo/bar

    HTTP/1.1 401 Unauthorized
    WWW-Authenticate: Bearer realm="registry.docker.io",
                      error="invalid_token",
                      error_description="The access token expired"

Example response when using token with insufficient scope:

	```
	GET /v1/image/foo/bar

    HTTP/1.1 401 Unauthorized
    WWW-Authenticate: Bearer realm="registry.docker.io",
                      error="insufficient_scope",
                      error_description="unauthorized scope: foo/bar:pull"
    ```

https://tools.ietf.org/html/rfc6750#section-3.1

Q: What realm do we use here?

### Storage Layout

	/storage/
		-><namespace>/<repository>
			-> manifests/
				<named
			-> layers/
				<split naming sha512 hashes>
			-> tarsums
				v1/sha512/
					<layer links>
			->tags/
		tmp/
			<space for temporary layer uploads>

## Roadmap

- [ ] Write Registry REST API V2 proposal
	- [ ] Solicit feedback
- [ ] Implement prototype API server
- [ ] Implement prototype API client
- [ ] 

V2: Image is a standalone json file
	- name
	- list of tarsums
	- signature
	- metadata
	- image is versioned

	tarsum: versioned hash algorithm for layer

Layers should not be shared among users (tarsum collision/poison attack?)
	- Need to trust tarsum to have common repo share
	- Need to understand access model for who has right to image file


TODO:

- Manifest fetch
- Layer fetching process
- Underlying directory layout

Questions:

1. What does the directory layout look like?

2. Should layers be shared between namespaces?

3. Layer files with identical tarsums may have different checksums (sha,
   etc.). During a resumable upload, should the client specify a hash so we
   ensure that the upload is resumed with the identical file?

4. How do we handle coordination and locking? Redis.

5. Do we have session state in addition to bearer token?

6. How does image signature check work? Are the plans to use the bearer token
   from the auth server overlapping with this?

Resumable upload specifications:

http://tus.io/protocols/resumable-upload.html
https://developers.google.com/youtube/v3/guides/using_resumable_upload_protocol