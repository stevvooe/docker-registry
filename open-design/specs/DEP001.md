# DEP001: Registry JSON API V2

## Abstract

The docker registry is a service to manage information about docker images and
enable their distribution. While the current registry is usable, there are
several problems with the  implementation that have led to this proposal.

For relevant details on the purpose of this proposal, please see the following
issues:

- docker/docker-registry#612
- docker/docker#8093

The main driver of this proposal are changes to the docker the image format,
covered in docker/docker#8093. The new, self-contained image manifest
simplifies the underlying backend layout. To reduce bandwidth usage, the new
registry will be architected to avoid uploading existing layers and will
support resumable layer uploads.

While out of scope for this specification, the URI layout of the new API will
be structured to support a rich Authentication and Authorization model by
leveraging namespaces.

Furthermore, to bring docker registry in line with docker core, the registry
will be rewritten in Go.

## Scope

This specification covers the URL layout and protocols of the Docker Registry
V2 JSON API. This includes the following features:

- Namespace-oriented URI Layout
- PUSH/PULL registry server for V2 image format
- Resumable layer PUSH support
- V2 Client library implementation

While authentication and authorization support will influence this
specification, details of the protocol will be left to a future specification.
Other features marked as next generation will be incorporated when the initial
support is complete. Please see the road map for details.

## Use Cases

For the most part, the use cases of the former registry API appy to the new
version. Differentiating uses cases are covered below.

### Resumable Push

Company X's build servers lose connectivity to docker registry before
completing an image layer transfer. After connectivity returns, the build
server attempts to re-upload the image. The registry notifies the build server
that the upload has already been partially attempted. The build server
responds by only sending the remaining data to complete the image file.

### Resumable Pull

Company X is having more connecitivity problems but this time in their
deployment datacenter. When downloading an image, the connection is
interrupted before completion. The client keeps the partial data and uses http
Range requests to avoid downloading repeated data.

### Layer Upload De-duplication

Company Y's build system creates two identical docker layers from build
processes A and B. Build process A completes uploading the layer before B.
When process B attempts to upload the layer, the registry indicates that its
not necessary because the layer is already known.

If process A and B upload the same layer at the same time, both operations
will proceed and the first to complete will be stored in the registry (Note:
we may modify this to prevent dogpile with some locking mechanism).

## Dependencies

TODO(stevvooe): There are probably blockers that need to be documented here.

## Proposal

This section covers proposed client flows and details of the proposed API
endpoints. All endpoints will be prefixed by the API version and the
repository name:

	/v2/<name>/

### Pulling An Image

An "image" is a combination of a JSON manifest and individual layer files. The
process of pulling an image centers around retrieving these two components.

The first step in pulling an image is to retrieve the manifest. The relevant fields
for the registry are the following:

 field    | description                                    |
----------|------------------------------------------------|
name      | The name of the image.                         |
tag       | The tag for this version of the image.         |
fsLayers  | A list of layer descriptors (including tarsum) |
signature | A JWS used to verify the manifest content      |

For more information about the manifest format, please see docker/docker#8093.

When the manifest is in hand, the client must verify the signature to ensure
the names and layers are valid. Once confirmed, the client will then use the
tarsums to download the indvidual layers.

The API details follow.

#### Pulling An Image Manifest

The image manifest can be fetched with one of the two following urls:

	GET /v2/<name>/image
	GET /v2/<name>/image/<tag>

The "name" parameter should be the name of the requested image and is
required. The tag portion of the manifest is optional and if not specified,
the default tag "latest" will be used.

If the image exists and the response is successful, the image manifest
will be returned, with the following format:

```
{
   "name": <name>,
   "tag": <tag>,
   "fsLayers": [
      {
         "blobSum": <tarsum>
      },
      ...
    ]
   ],
   "history": <v1 images>, 
   "signature": <JWS>
}
```

Please see docker/docker#8093 for details of this format.

### Pushing An Image

Pushing an image works in the opposite order as a pull. After assembling an
image manifest, the client must first push all of the relevant layers.


	PUT /v2/<name>/image
	PUT /v2/<name>/image/<tag>

	DELETE /v2/<name>/image/<tag>


#### PUSH Image


#####


##### List Tags

	GET /v2/<name>/image/tags

#### Layers

##### Pulling a Layer

Pulling a layer is carried out by a standard http request. The URL 

	GET /v2/<namespace>/layer/<tarsum>

##### PUSH Layer

All layer uploads use two steps to manage the upload process. The first step
starts the upload in the registry service, returning a url to carry out the
second step. The second step uses the upload url to transfer the actual data.
Uploads are started with a POST request which returns a url that can be used
to push data and check upload status.

The `Location` header will be used to communicate the upload location after
each request. While it won't change in the this specification, clients should
use the most recent value returned by the API.

To begin the process, a POST request should be issued in the following format:

	POST /v2/<namespace>/layer/<tarsum>?length=<size of layer file>&(md5|sha1|sha256|sha512)=<checksum>
	Host: <registry host>

The parameters of this request are the owner namespace, the layer tarsum and
optionally a checksum, which will used to validate that the upload is
complete. These parameters may be submitted as part of the url query string or
as standard form parameters.

If the layer with the tarsum is already present in the namespace, a `304 Not
Modified` response will be returned:

	304 Not Modified
	Location: /v2/<namespace>/layer/<tarsum>

If successful, a `202 Accepted` response will be returned with the upload URL
in the `Location` header:

	202 Accepted
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Range: bytes=0-<offset>/<length>
	Content-Length: 0

The rest of the upload process can be carried out with the returned url,
called the "Upload URL" from the Location header. All responses to the upload
url, whether sending data or getting status, will be in this format.

In addition to the `Location` header, the response will have a `Range` header,
indicating the progress of the upload. The progress and chunk coordination of
the upload process will be coordinated through the `Range` header. While this
is a non-standard use of the `Range` header, there are examples of [similar
approaches](https://developers.google.com/youtube/v3/guides/using_res
umable_upload_protocol) in APIs with heavy use.

For an upload that just started, for an example with a 1000 byte layer file,
the `Range` header would be as follows:

	Range: bytes=0-0/1000

To get the status of an upload, issue a GET request to the upload URL:

	GET /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Host: <registry host>

The response will be similar to the above, except will return 204 status:

	204 No Content
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Range: bytes=0-<offset>/<length>

Q: Should this be a 3xx series response? Perhaps, the service should not
really return a 2xx response until the upload is complete. This spec is
written such that the upload is not complete until a 201 response is returned.

To carry out a "monolithic" upload, one can simply put the entire content blob
to the provided URL:

	PUT /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Content-Length: <size of layer>
	Content-Type: application/octet-stream

	<Layer Binary Data>

If successful, the server will return a 201 Created response,indicating the
upload is complete:

	201 Created
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Content-Length: 0

To carry out an upload of a chunk, the client can specify a range header and
only include that part of the layer file:

	PUT /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Content-Length: <size of chunk>
	Content-Range: <start of range>-<end of range>/<layer size>
	Content-Type: application/octet-stream

	<Layer Chunk Binary Data>

There is no enforcement on layer chunk splits other than that the server must
receive them in order. The server may enforce a minimum chunk size. If the
server cannot accept the chunk, a `416 Requested Range Not Satisfiable`
response will be returned and will include a `Range` header indicating the
current status:

	416 Requested Range Not Satisfiable
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Range: 0-<last valid range>/<layer size>
	Content-Length: 0

If this response is received, the client should resume from the "last valid
range" and upload subsequent chunk. A 416 will be returned under the following
conditions:

- Invalid Content-Range header format
- Out of order chunk: the range of the next chunk must start after the "last
  valid range" from the last response.

When a chunk is accepted as part of the upload, a `202 Accepted` response will
be returned, including a `Range` header with the current upload status:

	202 Accepted
	Location: /v2/<namespace>/layer/<tarsum>/upload/<uuid>
	Range: bytes=0-<offset>/<length>
	Content-Length: 0

When the last chunk is received and the layer has been validated, the client
will receive a `201 Created` response:

	201 Created
	Location: /v2/<namespace>/layer/<tarsum>
	Content-Length: 0

The `Location` header will contain the registry URL to access the accepted
layer file.

If a 502, 503 or 504 error is received, the client should assume that the
download can proceed due to a temporary condition, honoring the appropriate
retry mechanism. Other 5xx errors should be treated as terminal.

If there is a problem with the upload, a 4xx error will be returned indicating
the problem. After receiving a 4xx response (except 416, as called out above),
the upload will be considered failed and the client should take appropriate
action.

The failure condition will be provided in a json response body, with the
following format:

	{
		"code": <error identifier>,
		"message": <message describing condition>
	}

The following table covers the various error conditions that may be returned
after completing a layer upload:

 Code            | Message                                          |
-----------------|--------------------------------------------------|
INVALID_CHECKSUM | provided checksum did not match uploaded content |
INVALID_LENGTH   | provided length did not match content length     |
INVALID_TARSUM	 | provided tarsum did not match binary content     |

Note that the upload url will not be available forever. If the upload uuid is
unknown to the registry, a `404 Not Found` (maybe `410 Gone`?) response will
be returned and the client must restart the upload process.

## Roadmap

- [ ] Write Registry REST API V2 proposal
	- [ ] Solicit feedback
- [ ] Implement V2 API server
	- [ ] Basic Layer API
	- [ ] Basic Image API
	- [ ] Resumable upload support
- [ ] Implement V2 API client
- [ ] Build unit tests
- [ ] Port docker to use client from registry project for v2 pushes
